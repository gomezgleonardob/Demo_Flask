\chapter{Números primos}

El siguiente programa muestra la cantidad de números primos indicada por
el usuario:

En este programa, vemos que es posible declarar varias variables del
mismo tipo en una única sentencia (\lstinline!primos_por_mostrar!,
\lstinline!n! y \lstinline!d!).

También aprovechamos de presentar cómo se hacen los comentarios en C:
comienzan con \lstinline!/*! y terminan con \lstinline!*/!.

Escriba, compile y ejecute este programa.

\section{Sentencias de control: while, for e if}

Este programa muestra tres de las sentencias de control de C, que son
equivalentes a sus tocayos de Python: \lstinline!while!, \lstinline!for!
e \lstinline!if!.

El \lstinline!while! y el \lstinline!if! son sencillos. Hay que tener en
cuenta que la condición debe ir necesariamente entre paréntesis. El
contenido no se indica usando indentación, sino que encerrándolo entre
paréntesis de llave:

\begin{lstlisting}
while (condicion) {
    /* ... */
}

if (condicion) {
    /* ... */
}
\end{lstlisting}

(Aunque al compilador la indentación no le interesa, a los seres humanos
sí les ayuda a entender mejor el código, por lo que no indentar es una
pésima idea.)

Al igual que en Python, el \lstinline!if! puede ir seguido de un
\lstinline!else!. El \lstinline!elif! de Python no existe en C, pues es
legal escribir \lstinline!else if!.

El ciclo \lstinline!for! es un poco diferente. Entre los paréntesis
tiene tres partes separadas por punto y coma:

\begin{lstlisting}
for (inicializacion; condicion; actualizacion) {
    /* ... */
}
\end{lstlisting}

La inicialización se ejecuta una vez, antes de iniciar el ciclo. Aquí se
suele asignar un valor inicial a un contador.

La actualización es la parte donde se modifica el valor del contador al
final de cada iteración.

La condición es evaluada después de cada actualización, para decidir si
se continúa o no ejecutando el ciclo.

Algunos ejemplos de ciclos \lstinline!for! en C, junto con sus
equivalentes en Python:

\begin{lstlisting}
for (i = 0; i < N; ++i)       /* for i in range(N):         */
for (i = 5; i < 10; ++i)      /* for i in range(5, 10):     */
for (i = 2; i < 30; i += 2)   /* for i in range(2, 30, 2):  */
for (i = 40; i > 0; --i)      /* for i in range(40, 0, -1): */
for (i = 1; i <= N; ++i)      /* for i in range(1, N + 1):  */
\end{lstlisting}

Las sentencias \lstinline!break! y \lstinline!continue! de Python
también funcionan en C.

\section{Operadores de incremento y decremento}

La expresión \lstinline!n++! incrementa en uno el valor de
\lstinline!n!. Es decir, si \lstinline!n! tiene el valor 15, después de
hacer \lstinline!n++! tendrá el valor 16.

De manera similar, \lstinline!primos_por_mostrar--! reduce en uno el
valor de \lstinline!primos_por_mostrar!. Inicialmente esta variable
tiene el valor ingresado por el usuario, y luego va decreciendo hasta
llegar a cero. Cuando esto ocurre, el ciclo \lstinline!while! se
termina.

Ambos operadores pueden ir antes o después de la variable:

\begin{lstlisting}
n++;
++n;
\end{lstlisting}

Ambas modifican el valor de \lstinline!n! de la misma manera, pero
existe una diferencia sutil entre ambos que por ahora omitiremos.

\section{Valores lógicos}

En C no existe un tipo de datos para representar valores lógicos, como
el tipo \lstinline!bool! de Python. En C, \textbf{los valores lógicos
son enteros}. El valor cero es interpretado como falso, y cualquier otro
valor como verdadero.

Como ilustración, nuestro programa usa la variable \lstinline!es_primo!
para recordar si el número \lstinline!n! que se está analizando en cada
iteración es o no primo. Esta variable es entera, y su valor es cambiado
a cero apenas se encuentra un divisor.

Como los enteros pueden ser interpretados como valores lógicos, el ciclo
\lstinline!while! de nuestro programa también podría haber sido escrito
así:

\begin{lstlisting}
while (primos_por_mostrar) {
    /* ... */
}
\end{lstlisting}

ya que esto también haría que el ciclo terminara cuando la variable
llega a cero, porque en este caso sería interpretado como una condición
falsa. Haga la prueba, y convénzase de que funciona.

Los operadores lógicos en C son:

\begin{itemize}
\item
  \lstinline!&&! (y),
\item
  \lstinline!||! (o),
\item
  \lstinline"!" (negación).
\end{itemize}

Por ejemplo, si uno quisiera modificar el programa para que mostrara
sólo los números compuestos que terminan en 7, habría que cambiar la
condición del último \lstinline!if! por la siguiente:

\begin{lstlisting}
if (!es_primo && n % 10 == 7) {
    /* ... */
}
\end{lstlisting}

Los operadores \lstinline!==!, \lstinline"!=", \lstinline!<!,
\lstinline!>!, \lstinline!<=! y \lstinline!>=! funcionan de la misma
manera que en Python.

Uno de los errores más comunes en C es confundir el operador de igualdad
\lstinline!==! con la asignación \lstinline!=!. En C es legal poner una
asignación dentro de la condición de un \lstinline!if! o de un
\lstinline!while!, por lo que un programa como éste:

\begin{lstlisting}
if (x = 2) {
    /* ... */
}
\end{lstlisting}

compilará y se ejecutará sin errores, pero probablemente no hará lo que
nosotros esperamos: en vez de verificar que \lstinline!x! vale 2,
¡modificará \lstinline!x! para que lo valga!

\section{Ejercicios}

Modifique el programa de arriba para que, en vez de mostrar una cierta
cantidad de números primos, muestre todos los números primos menores que
\emph{m}.

A continuación, modifíquelo para que en lugar de mostrar sólo los
números primos los muestre todos, indicando para cada uno de ellos si es
primo o compuesto:
