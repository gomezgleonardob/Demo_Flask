\chapter{Datos de una persona}

El siguiente programa le pide al usuario ingresar su nombre completo, su
rut y su fecha de nacimiento.

Como salida, se muestra la edad del usuario.

Además, el programa verifica que la fecha de nacimiento sea válida,
revisando que el mes esté entre 1 y 12, y que el día tenga sentido para
ese mes. Para simplificar, nos hemos echado los años bisiestos al
bolsillo.

\section{Macros de preprocesador}

La primera cosa extraña que vemos en este programa son las líneas que
comienzan con \lstinline!#define!. Estas líneas son instrucciones para
el \textbf{preprocesador}, que es un componente del compilador que hace
algunas sustituciones en el código antes de que comience realmente a ser
compilado.

Estas sustituciones se llaman \textbf{macros}, y son definidas por el
programador usando la instrucción \lstinline!#define!. Cada vez que
aparece la macro en el código, el preprocesador la reemplaza
literalmente por lo que aparezca a su derecha en el \lstinline!#define!.

Es común usar macros para definir una única vez al principio del
programa los largos de los arreglos. Estos valores suelen aparecer
muchas varias veces durante el programa; por ejemplo, en las
declaraciones y en los ciclos que los recorren.

En nuestro programa, hemos definido las macros \lstinline!LARGO_NOMBRE!
y \lstinline!LARGO_RUT!, que son los largos de los strings. Si más
adelante uno quisiera modificar el programa para que alguno de estos
strings tenga un largo diferente, bastaría con modificar la macro
asociada para que automáticamente el programa siga estando correcto.

Hay que tener muy claro que \textbf{las macros no son variables}. Son
sólo abreviaciones que son reemplazadas tal cual cada vez que aparecen
en el código. Para distinguirlas de las variables, se sigue la
convención de ponerle a las macros nombres en mayúsculas.

En la línea de comandos, usted puede usar el programa \lstinline!cpp!
para ver cómo queda el código después de ser preprocesado:

\begin{lstlisting}
$ cpp personas.c
\end{lstlisting}

\section{Estructuras}

Una \textbf{estructura} es un tipo de datos que agrupa varios valores en
uno solo.

A diferencia de los arreglos, los componentes de una estructura pueden
ser de tipos diferentes.

Las estructuras en C se usan para lo mismo que las tuplas en Python:
para agrupar datos que, por su naturaleza, deben ser tratados como un
único valor.

El ejemplo típico es crear una estructura para almacenar una fecha:

\begin{lstlisting}
struct fecha {
    int dia;
    int mes;
    int anno;
};
\end{lstlisting}

Esta definición crea un nuevo tipo de datos llamado
\lstinline!struct fecha!, que contiene tres valores enteros. El punto y
coma después de la llave es obligatorio; un error muy común es omitirlo.

Una variable de tipo \lstinline!struct fecha! debe ser declarada de la
misma forma que las demás variables:

\begin{lstlisting}
struct fecha f;
\end{lstlisting}

Una vez declarada la variable \lstinline!f!, sus miembros pueden ser
accedidos poniendo su nombre después de un punto:

\begin{lstlisting}
f.dia = 21;
f.mes = 5;
f.anno = 1879;
\end{lstlisting}

Note que las estructuras no se desempaquetan como las tuplas de Python.
No es necesario ya que se puede acceder a los campos a través de su
nombre, y no por su posición.

Los campos de una estructura pueden ser de cualquier tipo, incluso
arreglos u otra estructura. En el ejemplo, la estructura
\lstinline!persona! está compuesta de dos strings y una estructura
\lstinline!fecha!.

\section{Inicialización de arreglos y estructuras}

La función \lstinline!fecha_es_valida! utiliza el arreglo
\lstinline!dias_mes! para tener a la mano cuántos días tiene cada mes.

Para que el mes \lstinline!m! esté asociado al elemento \lstinline!m!
del arreglo, dejamos un valor de relleno en la posición 0, que no
corresponderá a ningún mes.

En vez de llenar el arreglo elemento por elemento:

\begin{lstlisting}
dias_mes[1] = 31;
dias_mes[2] = 28;
dias_mes[3] = 31;
/* ... */
\end{lstlisting}

podemos usar la siguiente sintaxis para inicializarlo:

\begin{lstlisting}
int dias_mes[] = {0, 31, 28, 31, /* ... */ };
\end{lstlisting}

Al inicializar el arreglo de esta manera no es necesario especificar su
tamaño. En nuestro programa, el arreglo \lstinline!dias_mes! será de
largo trece.

La misma sintaxis se puede usar para inicializar los elementos de una
estructura:

\begin{lstlisting}
struct fecha hoy = {29, 2, 2011};
\end{lstlisting}

La sintaxis de inicialización sólo puede ser usada en la misma
declaración, no más adelante en el programa:

\begin{lstlisting}
int a[5];
a = {900, 100, 600, 300, 200};  /* Esto es ilegal. */
\end{lstlisting}

\section{Leer una línea completa}

El descriptor de formato \lstinline!%s! indica a la función
\lstinline!scanf! que debe leer un string. Lo que hace la función es
leer texto hasta encontrarse con el primer caracter en blanco (como un
espacio o un salto de línea).

Esto no resulta útil cuando el string que interesa sí tiene espacios
entre medio. En el caso de nuestro programa, necesitamos un nombre
completo, en que el nombre y el apellido están separados por un espacio.

Para leer el nombre completo del usuario, usamos el descriptor de
formato \lstinline!%[^\n]!. Esto significa literalmente «leer todos los
caracteres que no sean saltos de línea».

\section{Salidas estándar y de error}

Cada vez que uno imprime cosas usando la función \lstinline!printf!, lo
que realmente ocurre es que el texto es enviado a un flujo de datos
denominado \textbf{salida estándar}. Podemos pensar en la salida
estándar como un canal de comunicación entre nuestro programa y la
consola.

En todos los programas en C, la salida estándar está disponible para
escribir cosas en ella. Pero además los programas tienen también otro
flujo de datos, llamado \textbf{salida de error}, que está destinada
exclusivamente para escribir en ella mensajes de error.

Los nombres de las salidas estándar y de error en un programa son,
respectivamente, \lstinline!stdin! y \lstinline!stderr!.

En nuestro programa, usamos la salida de error para imprimir un mensaje
antes de abortar el programa cuando se ha ingresado una fecha inválida.
Para esto, usamos la función \lstinline!fprintf!. Esta función es muy
parecida a \lstinline!printf!, salvo que recibe como primer parámetro el
flujo de datos en que se escribirá el mensaje. Más adelante utilizaremos
\lstinline!fprintf! para escribir datos en archivos.

Por omisión, ambas salidas están conectadas con la consola, por lo que
los mensajes impresos en ambas aparecen mezclados unos con otros, sin
distinción. La gracia es que es posible redirigir por separado a
cualquiera de ellas hacia otros mecanismos de salida, como un archivo, o
de frentón suprimirlos. Por lo tanto, es una buena práctica escribir los
mensajes de error en \lstinline!stderr!.

\section{Ejercicios}

¿Qué imprime el siguiente programa? Pruebe el programa y explique el
resultado.
